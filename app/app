System.registerDynamic("npm:typescript@1.5.3.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {})();
  return _retrieveGlobal();
});

System.registerDynamic("npm:reflect-metadata@0.1.0.js", ["npm:reflect-metadata@0.1.0/Reflect.js"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:reflect-metadata@0.1.0/Reflect.js");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:reflect-metadata@0.1.0/Reflect.js", ["@empty"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var Reflect;
  (function(Reflect) {
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var __Metadata__ = new _WeakMap();
    function decorate(decorators, target, targetKey, targetDescriptor) {
      if (!IsUndefined(targetDescriptor)) {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsObject(target)) {
          throw new TypeError();
        } else if (IsUndefined(targetKey)) {
          throw new TypeError();
        } else if (!IsObject(targetDescriptor)) {
          throw new TypeError();
        }
        targetKey = ToPropertyKey(targetKey);
        return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
      } else if (!IsUndefined(targetKey)) {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsObject(target)) {
          throw new TypeError();
        }
        targetKey = ToPropertyKey(targetKey);
        return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
      } else {
        if (!IsArray(decorators)) {
          throw new TypeError();
        } else if (!IsConstructor(target)) {
          throw new TypeError();
        }
        return DecorateConstructor(decorators, target);
      }
    }
    Reflect.decorate = decorate;
    function metadata(metadataKey, metadataValue) {
      function decorator(target, targetKey) {
        if (!IsUndefined(targetKey)) {
          if (!IsObject(target)) {
            throw new TypeError();
          }
          targetKey = ToPropertyKey(targetKey);
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
        } else {
          if (!IsConstructor(target)) {
            throw new TypeError();
          }
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);
        }
      }
      return decorator;
    }
    Reflect.metadata = metadata;
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    function hasMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    function hasOwnMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    function getMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    function getOwnMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    function getMetadataKeys(target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    function getOwnMetadataKeys(target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    function deleteMetadata(metadataKey, target, targetKey) {
      if (!IsObject(target)) {
        throw new TypeError();
      } else if (!IsUndefined(targetKey)) {
        targetKey = ToPropertyKey(targetKey);
      }
      var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
      if (IsUndefined(metadataMap)) {
        return false;
      }
      if (!metadataMap.delete(metadataKey)) {
        return false;
      }
      if (metadataMap.size > 0) {
        return true;
      }
      var targetMetadata = __Metadata__.get(target);
      targetMetadata.delete(targetKey);
      if (targetMetadata.size > 0) {
        return true;
      }
      __Metadata__.delete(target);
      return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated)) {
          if (!IsConstructor(decorated)) {
            throw new TypeError();
          }
          target = decorated;
        }
      }
      return target;
    }
    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated)) {
          if (!IsObject(decorated)) {
            throw new TypeError();
          }
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        decorator(target, propertyKey);
      }
    }
    function GetOrCreateMetadataMap(target, targetKey, create) {
      var targetMetadata = __Metadata__.get(target);
      if (!targetMetadata) {
        if (!create) {
          return undefined;
        }
        targetMetadata = new _Map();
        __Metadata__.set(target, targetMetadata);
      }
      var keyMetadata = targetMetadata.get(targetKey);
      if (!keyMetadata) {
        if (!create) {
          return undefined;
        }
        keyMetadata = new _Map();
        targetMetadata.set(targetKey, keyMetadata);
      }
      return keyMetadata;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) {
        return true;
      }
      var parent = GetPrototypeOf(O);
      if (parent !== null) {
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      }
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (metadataMap === undefined) {
        return false;
      }
      return Boolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) {
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      var parent = GetPrototypeOf(O);
      if (parent !== null) {
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      }
      return undefined;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (metadataMap === undefined) {
        return undefined;
      }
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(O, P, true);
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = GetPrototypeOf(O);
      if (parent === null) {
        return ownKeys;
      }
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0) {
        return ownKeys;
      }
      if (ownKeys.length <= 0) {
        return parentKeys;
      }
      var set = new _Set();
      var keys = [];
      for (var _i = 0; _i < ownKeys.length; _i++) {
        var key = ownKeys[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0; _a < parentKeys.length; _a++) {
        var key = parentKeys[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(target, targetKey) {
      var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
      var keys = [];
      if (metadataMap) {
        metadataMap.forEach(function(_, key) {
          return keys.push(key);
        });
      }
      return keys;
    }
    function IsUndefined(x) {
      return x === undefined;
    }
    function IsArray(x) {
      return Array.isArray(x);
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function IsConstructor(x) {
      return typeof x === "function";
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function ToPropertyKey(value) {
      if (IsSymbol(value)) {
        return value;
      }
      return String(value);
    }
    function GetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype) {
        return proto;
      }
      if (proto !== functionPrototype) {
        return proto;
      }
      var prototype = O.prototype;
      var prototypeProto = Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype) {
        return proto;
      }
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function") {
        return proto;
      }
      if (constructor === O) {
        return proto;
      }
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      function Map() {
        this._keys = [];
        this._values = [];
        this._cache = cacheSentinel;
      }
      Map.prototype = {
        get size() {
          return this._keys.length;
        },
        has: function(key) {
          if (key === this._cache) {
            return true;
          }
          if (this._find(key) >= 0) {
            this._cache = key;
            return true;
          }
          return false;
        },
        get: function(key) {
          var index = this._find(key);
          if (index >= 0) {
            this._cache = key;
            return this._values[index];
          }
          return undefined;
        },
        set: function(key, value) {
          this.delete(key);
          this._keys.push(key);
          this._values.push(value);
          this._cache = key;
          return this;
        },
        delete: function(key) {
          var index = this._find(key);
          if (index >= 0) {
            this._keys.splice(index, 1);
            this._values.splice(index, 1);
            this._cache = cacheSentinel;
            return true;
          }
          return false;
        },
        clear: function() {
          this._keys.length = 0;
          this._values.length = 0;
          this._cache = cacheSentinel;
        },
        forEach: function(callback, thisArg) {
          var size = this.size;
          for (var i = 0; i < size; ++i) {
            var key = this._keys[i];
            var value = this._values[i];
            this._cache = key;
            callback.call(this, value, key, this);
          }
        },
        _find: function(key) {
          var keys = this._keys;
          var size = keys.length;
          for (var i = 0; i < size; ++i) {
            if (keys[i] === key) {
              return i;
            }
          }
          return -1;
        }
      };
      return Map;
    }
    function CreateSetPolyfill() {
      var cacheSentinel = {};
      function Set() {
        this._map = new _Map();
      }
      Set.prototype = {
        get size() {
          return this._map.length;
        },
        has: function(value) {
          return this._map.has(value);
        },
        add: function(value) {
          this._map.set(value, value);
          return this;
        },
        delete: function(value) {
          return this._map.delete(value);
        },
        clear: function() {
          this._map.clear();
        },
        forEach: function(callback, thisArg) {
          this._map.forEach(callback, thisArg);
        }
      };
      return Set;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var isNode = typeof global !== "undefined" && typeof module === "object" && typeof module.exports === "object" && typeof require === "function";
      var nodeCrypto = isNode && require("@empty");
      var hasOwn = Object.prototype.hasOwnProperty;
      var keys = {};
      var rootKey = CreateUniqueKey();
      function WeakMap() {
        this._key = CreateUniqueKey();
      }
      WeakMap.prototype = {
        has: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table) {
            return this._key in table;
          }
          return false;
        },
        get: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table) {
            return table[this._key];
          }
          return undefined;
        },
        set: function(target, value) {
          var table = GetOrCreateWeakMapTable(target, true);
          table[this._key] = value;
          return this;
        },
        delete: function(target) {
          var table = GetOrCreateWeakMapTable(target, false);
          if (table && this._key in table) {
            return delete table[this._key];
          }
          return false;
        },
        clear: function() {
          this._key = CreateUniqueKey();
        }
      };
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) {
          buffer[i] = Math.random() * 255 | 0;
        }
      }
      function GenRandomBytes(size) {
        if (nodeCrypto) {
          var data = nodeCrypto.randomBytes(size);
          return data;
        } else if (typeof Uint8Array === "function") {
          var data = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(data);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(data);
          } else {
            FillRandomBytes(data, size);
          }
          return data;
        } else {
          var data = new Array(size);
          FillRandomBytes(data, size);
          return data;
        }
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 0x4f | 0x40;
        data[8] = data[8] & 0xbf | 0x80;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8) {
            result += "-";
          }
          if (byte < 16) {
            result += "0";
          }
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
      function CreateUniqueKey() {
        var key;
        do {
          key = "@@WeakMap@@" + CreateUUID();
        } while (hasOwn.call(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create) {
            return undefined;
          }
          Object.defineProperty(target, rootKey, {value: Object.create(null)});
        }
        return target[rootKey];
      }
      return WeakMap;
    }
    (function(__global) {
      if (typeof __global.Reflect !== "undefined") {
        if (__global.Reflect !== Reflect) {
          for (var p in Reflect) {
            __global.Reflect[p] = Reflect[p];
          }
        }
      } else {
        __global.Reflect = Reflect;
      }
    })(typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof global !== "undefined" ? global : Function("return this;")());
  })(Reflect || (Reflect = {}));
  global.define = __define;
  return module.exports;
});

System.register("src/ngtt.ts", ['typescript', 'reflect-metadata', './ngDecorator', './ng/config', './core/annotations/decorators', './util/decorators', './ng/adapterManager', './ng/adapters/adapters'], function(exports_1) {
    var r, ngDecorator_1, _config, adapterManager_1, adapters_1;
    var x, config;
    return {
        setters:[
            function (_typescript_1) {
                exports_1("ArrayLiteralExpression", _typescript_1["ArrayLiteralExpression"]);
            },
            function (_r) {
                r = _r;
            },
            function (_ngDecorator_1) {
                ngDecorator_1 = _ngDecorator_1;
            },
            function (__config) {
                _config = __config;
            },
            function (_decorators_1) {
                exports_1("Component", _decorators_1["Component"]);
                exports_1("Directive", _decorators_1["Directive"]);
                exports_1("View", _decorators_1["View"]);
            },
            function (_decorators_2) {
                exports_1("Class", _decorators_2["Class"]);
                exports_1("ClassDefinition", _decorators_2["ClassDefinition"]);
                exports_1("TypeDecorator", _decorators_2["TypeDecorator"]);
            },
            function (_adapterManager_1) {
                adapterManager_1 = _adapterManager_1;
            },
            function (_adapters_1) {
                adapters_1 = _adapters_1;
            }],
        execute: function() {
            exports_1("x", x = r);
            exports_1("config", config = _config);
            adapterManager_1.registerAdapter(adapters_1.ControllerAdapter, adapterManager_1.AngularLegacyViewType.Controller);
            adapterManager_1.registerAdapter(adapters_1.DirectiveAdapter, adapterManager_1.AngularLegacyViewType.Directive);
            adapterManager_1.registerAdapter(adapters_1.NgRouteAdapter, adapterManager_1.AngularLegacyViewType.Routing);
            ngDecorator_1.init();
        }
    }
});

/// <reference path="../typings/tsd.d.ts" />
System.register("src/ngDecorator.ts", [], function(exports_1) {
    var orgModuleFn, moduleCache, moduleNotifyCache;
    function module(name, requires, configFn) {
        var md = orgModuleFn.apply(this, arguments);
        if (requires && requires.length > 0) {
            moduleCache[name] = md;
            moduleNotifyCache.forEach(function (mn) { return mn.onNewModuleAdded.call(mn, name); });
        }
        return md;
    }
    function hasModule(name) {
        return moduleCache.hasOwnProperty(name);
    }
    exports_1("hasModule", hasModule);
    function notifyOnNewModule(messenger) {
        moduleNotifyCache.push(messenger);
    }
    exports_1("notifyOnNewModule", notifyOnNewModule);
    function init() {
        if (!angular) {
            throw new Error("angular not here.");
        }
        if (orgModuleFn)
            return;
        orgModuleFn = angular.module;
        angular.module = module;
    }
    exports_1("init", init);
    return {
        setters:[],
        execute: function() {
            moduleCache = {};
            moduleNotifyCache = [];
        }
    }
});

System.register("src/ng/config.ts", [], function(exports_1) {
    var ngApp;
    return {
        setters:[],
        execute: function() {
            exports_1("ngApp", ngApp = "");
        }
    }
});

/// <reference path="../../../typings/tsd.d.ts" />
System.register("src/core/annotations/decorators.ts", ['./view', './annotations', '../../util/decorators'], function(exports_1) {
    var view_1, annotations_1, decorators_1;
    var Component, Directive, View;
    return {
        setters:[
            function (_view_1) {
                view_1 = _view_1;
            },
            function (_annotations_1) {
                annotations_1 = _annotations_1;
            },
            function (_decorators_1) {
                decorators_1 = _decorators_1;
            }],
        execute: function() {
            /**
             * {@link Component} factory function.
             */
            exports_1("Component", Component = decorators_1.makeDecorator(annotations_1.ComponentAnnotation, function (fn) { return fn.View = View; }));
            /**
             * {@link Directive} factory function.
             */
            exports_1("Directive", Directive = decorators_1.makeDecorator(annotations_1.DirectiveAnnotation));
            exports_1("View", View = decorators_1.makeDecorator(view_1.ViewAnnotation, function (fn) { return fn.View = View; }));
        }
    }
});

System.register("src/ng/adapterManager.ts", ['../ngDecorator', '../ng/config', "../facade/lang"], function(exports_1) {
    var ngDecorator_1, config, lang_1;
    var adapters, AnnotationType, AngularLegacyViewType, RegisterInstruction, Mgr, mgr;
    /**
     * Finds an annotation instance by its "type" name.
     * @param annotations
     * @param name
     * @returns {any}
     */
    function findAnnotation(annotations, name) {
        for (var i = 0; i < annotations.length; i++) {
            if (name === lang_1.getTypeName(annotations[i]))
                return annotations[i];
        }
        return null;
    }
    exports_1("findAnnotation", findAnnotation);
    function registerAdapter(adapterClass, legacyView) {
        if (!adapterClass || !legacyView)
            return;
        var lv;
        if (!Number.isNaN(Number(legacyView))) {
            lv = AngularLegacyViewType[legacyView];
        }
        else {
            lv = (AngularLegacyViewType.hasOwnProperty(legacyView)) ? legacyView : null;
        }
        if (lv) {
            adapters[lv] = adapterClass;
        }
        else {
            throw new Error("Unknown legacy view " + legacyView);
        }
    }
    exports_1("registerAdapter", registerAdapter);
    function registerLegacy(cls, annotations) {
        var instruction = new RegisterInstruction(cls, annotations);
        mgr.add(instruction);
    }
    exports_1("registerLegacy", registerLegacy);
    return {
        setters:[
            function (_ngDecorator_1) {
                ngDecorator_1 = _ngDecorator_1;
            },
            function (_config) {
                config = _config;
            },
            function (_lang_1) {
                lang_1 = _lang_1;
            }],
        execute: function() {
            adapters = {};
            /**
             * Types of annotations angular2 provides.
             */
            (function (AnnotationType) {
                AnnotationType[AnnotationType["Directive"] = 1] = "Directive";
                AnnotationType[AnnotationType["Component"] = 2] = "Component";
                AnnotationType[AnnotationType["View"] = 4] = "View";
            })(AnnotationType || (AnnotationType = {}));
            exports_1("AnnotationType", AnnotationType);
            /**
             * Types of UI components angularJS provides.
             */
            (function (AngularLegacyViewType) {
                AngularLegacyViewType[AngularLegacyViewType["Controller"] = 1] = "Controller";
                AngularLegacyViewType[AngularLegacyViewType["Directive"] = 2] = "Directive";
                AngularLegacyViewType[AngularLegacyViewType["Routing"] = 3] = "Routing";
            })(AngularLegacyViewType || (AngularLegacyViewType = {}));
            exports_1("AngularLegacyViewType", AngularLegacyViewType);
            RegisterInstruction = (function () {
                function RegisterInstruction(cls, annotations) {
                    this._cache = {};
                    this.cls = cls;
                    this.annotations = annotations;
                }
                /**
                 * Flatten (reduce) and array of annotations to a bit flag of AnnotationType.
                 * @param annotations
                 * @returns {number}
                 */
                RegisterInstruction.prototype._flatten = function () {
                    var flatValue = 0;
                    for (var i = 0; i < this.annotations.length; i++) {
                        var name = lang_1.getTypeName(this.annotations[i]);
                        if (AnnotationType.hasOwnProperty(name)) {
                            flatValue = flatValue | AnnotationType[name];
                        }
                    }
                    return flatValue;
                };
                RegisterInstruction.prototype._mapAnnotationsToLegacyView = function () {
                    var annotationFlag = this._flatten();
                    var map;
                    switch (annotationFlag) {
                        case 1:
                            map = AngularLegacyViewType.Directive;
                            break;
                        case 6: {
                            var cmpAnnotation = findAnnotation(this.annotations, AnnotationType[2]);
                            map = (cmpAnnotation && cmpAnnotation.selector && typeof cmpAnnotation.selector === "string") ?
                                AngularLegacyViewType.Directive : AngularLegacyViewType.Controller;
                            break;
                        }
                    }
                    return map;
                };
                RegisterInstruction.prototype.destroy = function () {
                    this._cache = undefined;
                };
                Object.defineProperty(RegisterInstruction.prototype, "legacyViewType", {
                    get: function () {
                        if (!this._cache.hasOwnProperty('legacyViewType')) {
                            var mapped = this._mapAnnotationsToLegacyView();
                            if (mapped) {
                                this._cache.legacyViewType = mapped;
                            }
                        }
                        return this._cache.legacyViewType;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RegisterInstruction.prototype, "directive", {
                    get: function () {
                        if (!this._cache.hasOwnProperty('Directive')) {
                            var value = findAnnotation(this.annotations, AnnotationType[AnnotationType.Directive]);
                            if (value) {
                                this._cache.Directive = value;
                            }
                            else {
                                return null;
                            }
                        }
                        return this._cache.Directive;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RegisterInstruction.prototype, "component", {
                    get: function () {
                        if (!this._cache.hasOwnProperty('Component')) {
                            var value = findAnnotation(this.annotations, AnnotationType[AnnotationType.Component]);
                            if (value) {
                                this._cache.Component = value;
                            }
                            else {
                                return null;
                            }
                        }
                        return this._cache.Component;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RegisterInstruction.prototype, "view", {
                    get: function () {
                        if (!this._cache.hasOwnProperty('View')) {
                            var value = findAnnotation(this.annotations, AnnotationType[AnnotationType.View]);
                            if (value) {
                                this._cache.View = value;
                            }
                            else {
                                return null;
                            }
                        }
                        return this._cache.View;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RegisterInstruction.prototype, "ngAppName", {
                    get: function () {
                        if (!this._cache.hasOwnProperty('ngAppName')) {
                            var a = this.component || this.directive;
                            var meta = (a) ? a._ngtt : undefined;
                            this._cache.ngAppName = (meta && meta.ngApp) ? meta.ngApp : config.ngApp;
                        }
                        return this._cache.ngAppName || null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RegisterInstruction.prototype, "ngModule", {
                    get: function () {
                        return angular.module(this.ngAppName);
                    },
                    enumerable: true,
                    configurable: true
                });
                return RegisterInstruction;
            })();
            exports_1("RegisterInstruction", RegisterInstruction);
            Mgr = (function () {
                function Mgr() {
                    this.instructions = [];
                }
                Mgr.prototype.onNewModuleAdded = function (name) {
                    for (var i = this.instructions.length - 1; i >= 0; i--) {
                        if (this.instructions[i].ngAppName == name) {
                            this.register(this.instructions.pop());
                        }
                    }
                };
                Mgr.prototype.add = function (inst) {
                    if (ngDecorator_1.hasModule(inst.ngAppName)) {
                        this.register(inst);
                    }
                    else {
                        // search if we have the class, since 2 decorators will invoke twice...
                        for (var i = 0; i < this.instructions.length; i++) {
                            if (this.instructions[i].cls === inst.cls) {
                                this.instructions.splice(i, 1);
                                break;
                            }
                        }
                        this.instructions.push(inst);
                    }
                };
                Mgr.prototype.register = function (inst) {
                    if (!inst.legacyViewType) {
                        /*  TODO: save in a list, after angular is finished loading, display it.
                         this is because we run register for every annotation.
                         e.g: View + Component will run once for view which is invalid but 2nd time as a valid combination.
                         */
                        console.warn("Annotation implementation for " + lang_1.getTypeName(inst.cls) + " is invalid - component skipped.");
                        return;
                    }
                    var handler = adapters[AngularLegacyViewType[inst.legacyViewType]];
                    if (!handler) {
                        console.warn("Could not find an adapter of type '" + AngularLegacyViewType[inst.legacyViewType] + "' to handle '" + lang_1.getTypeName(inst.cls) + "' - component skipped.");
                        return;
                    }
                    new handler(inst).register();
                    handler = adapters[AngularLegacyViewType[AngularLegacyViewType.Routing]];
                    if (!handler) {
                        return;
                    }
                    new handler(inst).register();
                    //inst.destroy(); <- doesnt work, causes exception because the _cache is still needed after this.
                    //TODO: attach a function to the "run" block of an angular module and remove per run invocation for the specific recipes of that run.
                };
                return Mgr;
            })();
            exports_1("Mgr", Mgr);
            mgr = new Mgr();
            ngDecorator_1.notifyOnNewModule(mgr);
        }
    }
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};System.register("src/ng/adapters/adapters.ts", ["../../facade/lang", "./base", "./directive", "./ngRoute"], function(exports_1) {
    var lang_1, base_1;
    var ControllerAdapter;
    return {
        setters:[
            function (_lang_1) {
                lang_1 = _lang_1;
            },
            function (_base_1) {
                base_1 = _base_1;
            },
            function (_directive_1) {
                exports_1("DirectiveAdapter", _directive_1["DirectiveAdapter"]);
                exports_1("LinkingInstructionType", _directive_1["LinkingInstructionType"]);
            },
            function (_ngRoute_1) {
                exports_1("NgRouteAdapter", _ngRoute_1["NgRouteAdapter"]);
            }],
        execute: function() {
            ControllerAdapter = (function (_super) {
                __extends(ControllerAdapter, _super);
                function ControllerAdapter() {
                    _super.apply(this, arguments);
                }
                ControllerAdapter.prototype.register = function () {
                    this.inst.ngModule.controller(lang_1.getTypeName(this.inst.cls), this.inst.cls);
                };
                return ControllerAdapter;
            })(base_1.BaseAdapter);
            exports_1("ControllerAdapter", ControllerAdapter);
        }
    }
});

/// <reference path="../../typings/tsd.d.ts" />
/// <reference path="../facade/lang.ts" />
System.register("src/util/decorators.ts", ['../facade/lang', '../ng/adapterManager'], function(exports_1) {
    var lang_1, adapterManager_1;
    var Reflect;
    function extractAnnotation(annotation) {
        if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
            // it is a decorator, extract annotation
            annotation = annotation.annotation;
        }
        return annotation;
    }
    function applyParams(fnOrArray, key) {
        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
            fnOrArray === Number || fnOrArray === Array) {
            throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
        }
        if (lang_1.isFunction(fnOrArray)) {
            return fnOrArray;
        }
        else if (fnOrArray instanceof Array) {
            var annotations = fnOrArray;
            var fn = fnOrArray[fnOrArray.length - 1];
            if (!lang_1.isFunction(fn)) {
                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
            }
            var annoLength = annotations.length - 1;
            if (annoLength != fn.length) {
                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
            }
            var paramsAnnotations = [];
            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
                var paramAnnotations = [];
                paramsAnnotations.push(paramAnnotations);
                var annotation = annotations[i];
                if (annotation instanceof Array) {
                    for (var j = 0; j < annotation.length; j++) {
                        paramAnnotations.push(extractAnnotation(annotation[j]));
                    }
                }
                else if (lang_1.isFunction(annotation)) {
                    paramAnnotations.push(extractAnnotation(annotation));
                }
                else {
                    paramAnnotations.push(annotation);
                }
            }
            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
            return fn;
        }
        else {
            throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
        }
    }
    /**
     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
     *
     * ## Basic Example
     *
     * ```
     * var Greeter = ng.Class({
     *   constructor: function(name) {
     *     this.name = name;
     *   },
     *
     *   greet: function() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class Greeter {
     *   constructor(name) {
     *     this.name = name;
     *   }
     *
     *   greet() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * }
     * ```
     *
     * or equivalent to ES5:
     *
     * ```
     * var Greeter = function (name) {
     *   this.name = name;
     * }
     *
     * Greeter.prototype.greet = function () {
     *   alert('Hello ' + this.name + '!');
     * }
     * ```
     *
     * ## Example with parameter annotations
     *
     * ```
     * var MyService = neg.Class({
     *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
     *     ...
     *   }];
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class MyService {
     *   constructor(name: string, @Query() queryList: QueryList) {
     *     ...
     *   }
     * }
     * ```
     *
     * ## Example with inheritance
     *
     * ```
     * var Shape = ng.Class({
     *   constructor: (color) {
     *     this.color = color;
     *   }
     * });
     *
     * var Square = ng.Class({
     *   extends: Shape,
     *   constructor: function(color, size) {
     *     Shape.call(this, color);
     *     this.size = size;
     *   }
     * });
     * ```
     */
    function Class(clsDef) {
        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
        var proto = constructor.prototype;
        if (clsDef.hasOwnProperty('extends')) {
            if (lang_1.isFunction(clsDef.extends)) {
                constructor.prototype = proto =
                    Object.create(clsDef.extends.prototype);
            }
            else {
                throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
            }
        }
        for (var key in clsDef) {
            if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
                proto[key] = applyParams(clsDef[key], key);
            }
        }
        if (this && this.annotations instanceof Array) {
            Reflect.defineMetadata('annotations', this.annotations, constructor);
        }
        return constructor;
    }
    exports_1("Class", Class);
    function makeDecorator(annotationCls, chainFn) {
        if (chainFn === void 0) { chainFn = null; }
        function DecoratorFactory(objOrType) {
            var annotationInstance = new annotationCls(objOrType);
            if (this instanceof annotationCls) {
                return annotationInstance;
            }
            else {
                var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
                chainAnnotation.push(annotationInstance);
                var TypeDecorator = function TypeDecorator(cls) {
                    var annotations = Reflect.getOwnMetadata('annotations', cls);
                    annotations = annotations || [];
                    annotations.push(annotationInstance);
                    Reflect.defineMetadata('annotations', annotations, cls);
                    adapterManager_1.registerLegacy(cls, annotations);
                    return cls;
                };
                TypeDecorator.annotations = chainAnnotation;
                TypeDecorator.Class = Class;
                if (chainFn)
                    chainFn(TypeDecorator);
                return TypeDecorator;
            }
        }
        DecoratorFactory.prototype = Object.create(annotationCls.prototype);
        return DecoratorFactory;
    }
    exports_1("makeDecorator", makeDecorator);
    function makeParamDecorator(annotationCls) {
        function ParamDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var annotationInstance = Object.create(annotationCls.prototype);
            annotationCls.apply(annotationInstance, args);
            if (this instanceof annotationCls) {
                return annotationInstance;
            }
            else {
                ParamDecorator.annotation = annotationInstance;
                return ParamDecorator;
            }
            function ParamDecorator(cls, unusedKey, index) {
                var parameters = Reflect.getMetadata('parameters', cls);
                parameters = parameters || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= index) {
                    parameters.push(null);
                }
                parameters[index] = parameters[index] || [];
                var annotationsForParam = parameters[index];
                annotationsForParam.push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, cls);
                return cls;
            }
        }
        ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
        return ParamDecoratorFactory;
    }
    exports_1("makeParamDecorator", makeParamDecorator);
    return {
        setters:[
            function (_lang_1) {
                lang_1 = _lang_1;
            },
            function (_adapterManager_1) {
                adapterManager_1 = _adapterManager_1;
            }],
        execute: function() {
            Reflect = lang_1.global.Reflect;
            if (!(Reflect && Reflect.getMetadata)) {
                throw 'reflect-metadata shim is required when using class decorators';
            }
        }
    }
});

/* SEE: https://github.com/angular/angular/blob/master/modules/angular2/src/core/annotations/view.ts */
System.register("src/core/annotations/view.ts", ['../annotations_impl/view'], function(exports_1) {
    return {
        setters:[
            function (_view_1) {
                exports_1("ViewAnnotation", _view_1["View"]);
            }],
        execute: function() {
        }
    }
});

/// <reference path="../../typings/tsd.d.ts" />
System.register("src/facade/lang.ts", [], function(exports_1) {
    var global, isFunction, Type;
    function CONST() {
        return function (target) { return target; };
    }
    exports_1("CONST", CONST);
    function ABSTRACT() {
        return function (t) { return t; };
    }
    exports_1("ABSTRACT", ABSTRACT);
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf("\n");
        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
    }
    exports_1("stringify", stringify);
    /**
     * Returns the class name of an instance, or the class name if the type (constructor function) is provided.
     * @param clsOrObj
     * @returns {string}
     */
    function getTypeName(clsOrObj) {
        if (clsOrObj) {
            var matchStr;
            if (typeof clsOrObj === "function") {
                matchStr = clsOrObj.toString();
            }
            else if (clsOrObj.constructor && clsOrObj.constructor.toString) {
                matchStr = clsOrObj.constructor.toString();
            }
            if (matchStr) {
                var arr = matchStr.match(/function\s*(\w+)/);
                if (arr && arr.length == 2) {
                    return arr[1];
                }
            }
        }
        return undefined;
    }
    exports_1("getTypeName", getTypeName);
    return {
        setters:[],
        execute: function() {
            /* SEE: https://github.com/angular/angular/blob/master/modules/angular2/src/facade/lang.ts */
            exports_1("global", global = (typeof window === 'undefined' ? global : window));
            exports_1("isFunction", isFunction = angular.isFunction);
            exports_1("Type", Type = Function);
        }
    }
});

/* SEE: https://github.com/angular/angular/blob/master/modules/angular2/src/core/annotations/annotations.ts */
System.register("src/core/annotations/annotations.ts", ['../annotations_impl/annotations'], function(exports_1) {
    return {
        setters:[
            function (_annotations_1) {
                exports_1("INgttAnnotationMeta", _annotations_1["INgttAnnotationMeta"]);
                exports_1("ComponentAnnotation", _annotations_1["Component"]);
                exports_1("DirectiveAnnotation", _annotations_1["Directive"]);
            }],
        execute: function() {
        }
    }
});

/// <reference path="../../../typings/tsd.d.ts" />
System.register("src/ng/adapters/base.ts", [], function(exports_1) {
    var BaseAdapter;
    return {
        setters:[],
        execute: function() {
            BaseAdapter = (function () {
                function BaseAdapter(inst) {
                    this.inst = inst;
                }
                return BaseAdapter;
            })();
            exports_1("BaseAdapter", BaseAdapter);
        }
    }
});

/// <reference path="../../../typings/tsd.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};System.register("src/ng/adapters/directive.ts", ["./base"], function(exports_1) {
    var base_1;
    var LinkingInstructionType, HostItemType, DirectiveAdapter;
    function getHostType(name) {
        var result;
        if (!name) {
            result = HostItemType.invalid;
        }
        else {
            var _a = [name.substr(0, 1), name.substr(name.length - 1, 1)], first = _a[0], last = _a[1];
            if (first === "@") {
                result = (name.length > 1) ? HostItemType.action : HostItemType.invalid;
            }
            else {
                if (first === "[" && last === "]") {
                    result = (name.length > 2) ? HostItemType.property : HostItemType.invalid;
                }
                else if (first === "(" && last === ")") {
                    result = (name.length > 2) ? HostItemType.event : HostItemType.invalid;
                }
                else {
                    result = HostItemType.attribute;
                }
            }
        }
        return result;
    }
    /**
     * Inspect a linking function and return its location/type
     * Returns an enum flag, 1: linkFn, 2: link->pre, 4: link->post, 6: link->pre+post
     * @param obj
     * @returns {number}
     */
    function identifyLinkingFn(linkObj) {
        var fn, result = 0;
        if (linkObj) {
            if (angular.isFunction(linkObj)) {
                result = LinkingInstructionType.fn;
            }
            else {
                if (angular.isFunction(linkObj.pre)) {
                    result = result | LinkingInstructionType.pre;
                }
                if (angular.isFunction(linkObj.post)) {
                    result = result | LinkingInstructionType.post;
                }
            }
        }
        return result;
    }
    function linkFnWrapperFactory(originalLinkFn, beforeLink) {
        return function () {
            beforeLink.apply(this, arguments);
            return originalLinkFn.apply(this, arguments);
        }.bind(this);
    }
    /**
     * Wrap an IDirectiveLinkFn or IDirectiveLinkFn in IDirectivePrePost with a function that modifies things before invocation.
     * @param originalLink
     * @returns {ng.IDirectiveLinkFn | ng.IDirectivePrePost}
     */
    function linkWrapperFactory(originalLink, beforeLink) {
        var linkingConfig = identifyLinkingFn(originalLink);
        if (linkingConfig === LinkingInstructionType.fn) {
            return linkFnWrapperFactory.call(this, originalLink, beforeLink);
        }
        else if ((linkingConfig & LinkingInstructionType.pre) === LinkingInstructionType.pre) {
            var newLinkingObj = {};
            newLinkingObj.pre = linkFnWrapperFactory.call(this, originalLink.pre, beforeLink);
            newLinkingObj.post = originalLink.post;
            return newLinkingObj;
        }
        else if ((linkingConfig & LinkingInstructionType.post) === LinkingInstructionType.post) {
            var newLinkingObj = {};
            newLinkingObj.pre = originalLink.pre;
            newLinkingObj.post = linkFnWrapperFactory.call(this, originalLink.post, beforeLink);
            return newLinkingObj;
        }
        else {
            return originalLink;
        }
    }
    function compileWrapperFactory(originalCompileFn, beforeLink) {
        return function () {
            var linkObj = originalCompileFn.apply(this, arguments);
            return linkWrapperFactory.call(this, linkObj, beforeLink);
        }.bind(this);
    }
    return {
        setters:[
            function (_base_1) {
                base_1 = _base_1;
            }],
        execute: function() {
            (function (LinkingInstructionType) {
                LinkingInstructionType[LinkingInstructionType["fn"] = 1] = "fn";
                LinkingInstructionType[LinkingInstructionType["pre"] = 2] = "pre";
                LinkingInstructionType[LinkingInstructionType["post"] = 4] = "post";
            })(LinkingInstructionType || (LinkingInstructionType = {}));
            exports_1("LinkingInstructionType", LinkingInstructionType);
            (function (HostItemType) {
                HostItemType[HostItemType["event"] = 0] = "event";
                HostItemType[HostItemType["property"] = 1] = "property";
                HostItemType[HostItemType["attribute"] = 2] = "attribute";
                HostItemType[HostItemType["action"] = 3] = "action";
                HostItemType[HostItemType["invalid"] = 4] = "invalid";
            })(HostItemType || (HostItemType = {}));
            exports_1("HostItemType", HostItemType);
            DirectiveAdapter = (function (_super) {
                __extends(DirectiveAdapter, _super);
                function DirectiveAdapter() {
                    _super.apply(this, arguments);
                }
                DirectiveAdapter.prototype._populateHostMeta = function (host) {
                    this.hostMeta = {
                        events: {},
                        properties: {},
                        attributes: {},
                        actions: {}
                    };
                    if (host) {
                        for (var k in host) {
                            var hostType = getHostType(k);
                            switch (hostType) {
                                case HostItemType.action:
                                    this.hostMeta.actions[k.substr(1)] = host[k];
                                    break;
                                case HostItemType.property:
                                    this.hostMeta.properties[k.substr(1, k.length - 2)] = host[k];
                                    break;
                                case HostItemType.event:
                                    this.hostMeta.events[k.substr(1, k.length - 2)] = host[k];
                                    break;
                                case HostItemType.attribute:
                                    this.hostMeta.attributes[k] = host[k];
                                    break;
                            }
                        }
                    }
                };
                DirectiveAdapter.prototype.register = function () {
                    if (this.inst.component) {
                        this._populateHostMeta(this.inst.component.host);
                        this._registerView(this.inst.component, this.inst.view);
                    }
                    else if (this.inst.directive) {
                        this._populateHostMeta(this.inst.directive.host);
                        this._registerNoView(this.inst.directive);
                    }
                };
                DirectiveAdapter.prototype._beforeLink = function (scope, iElement, iAttrs, controller, transclude) {
                    // The actual place when are on an instance level of a directive.
                    // All other places instances of a directive type.
                    // Here we have virtual constructor to an instance of a directive.
                    // the context ("this") is the a "Component" instance, the only instance of Component for this directive as a type.
                    var self = this;
                    for (var k in self.$$ngtt.adapter.hostMeta.events) {
                    }
                    //console.log(this);
                    //console.log(controller);
                };
                /**
                 * A Directive constructor emulator.
                 * Why? Since Directive`s are plain objects (not instances) they are no good for NGTT,
                 * NGTT enforce directives as Classes so they can be instantiated, this is to future proof them for NG2 as much as possible.
                 * To compose a directive per its annotations it must be modified before sent to angular, also angular does not instantiate directives (creating them with new)
                 * Angular is all about DI so it will send some injections, we need to make sure they will get to the Class constructor.
                 * Since its a class and it requires instantiation (new) we need to work around that (there is no "apply" to new XXX()).
                 * Also, while at it, some modifications are made to support complex annotations.
                 * @param args
                 * @returns {Component}
                 * @private
                 */
                DirectiveAdapter.prototype._constructDirective = function (args) {
                    function Component(adapter, args) {
                        adapter.inst.cls.apply(this, args);
                        this.$$ngtt = {
                            adapter: adapter
                        };
                        if (angular.isFunction(this.controller)) {
                            var ctrl = this.controller;
                            this.controller = function () {
                                return ctrl.apply(this, arguments);
                            };
                            this.controller.$inject = ctrl.$inject;
                        }
                        // we want to control the linking function to support 'host' features in ng2
                        // for this we need to wrap the "link" function or link.pre\post function
                        if (angular.isFunction(this.compile)) {
                            // compile returns a LinkFn so we will wait for it, grab & wrap.
                            this.compile = compileWrapperFactory.call(this, this.compile, adapter._beforeLink);
                        }
                        else {
                            // direct wrap.
                            this.link = linkWrapperFactory.call(this, this.link, adapter._beforeLink);
                        }
                    }
                    Component.prototype = this.inst.cls.prototype;
                    return new Component(this, args);
                };
                DirectiveAdapter.prototype._directiveFactoryFactory = function () {
                    var factory = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i - 0] = arguments[_i];
                        }
                        return this._constructDirective(args);
                    }.bind(this);
                    factory.$inject = this.inst.cls.$inject;
                    return factory;
                };
                DirectiveAdapter.prototype._registerNoView = function (cmpt) {
                    this.inst.ngModule.directive(cmpt.selector, this._directiveFactoryFactory());
                };
                DirectiveAdapter.prototype._registerView = function (cmpt, view) {
                    if (view.template) {
                        this.inst.cls.prototype.template = view.template;
                    }
                    else if (view.templateUrl) {
                        this.inst.cls.prototype.templateUrl = view.templateUrl;
                    }
                    this.inst.ngModule.directive(cmpt.selector, this._directiveFactoryFactory());
                };
                return DirectiveAdapter;
            })(base_1.BaseAdapter);
            exports_1("DirectiveAdapter", DirectiveAdapter);
        }
    }
});

/// <reference path="../../../typings/tsd.d.ts" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};System.register("src/ng/adapters/ngRoute.ts", ["../../facade/lang", "./base"], function(exports_1) {
    var lang_1, base_1;
    var NgRouteAdapter;
    return {
        setters:[
            function (_lang_1) {
                lang_1 = _lang_1;
            },
            function (_base_1) {
                base_1 = _base_1;
            }],
        execute: function() {
            NgRouteAdapter = (function (_super) {
                __extends(NgRouteAdapter, _super);
                function NgRouteAdapter(inst) {
                    _super.call(this, inst);
                }
                NgRouteAdapter.prototype.routeConfig = function ($routeProvider) {
                    var appName = this.inst.ngAppName;
                    if (NgRouteAdapter.routeCache.hasOwnProperty(appName)) {
                        var arr = NgRouteAdapter.routeCache[appName];
                        while (arr.length > 0) {
                            var pr = arr.pop();
                            $routeProvider.when(pr.path, pr.route);
                        }
                    }
                };
                NgRouteAdapter.prototype.register = function () {
                    var ctrl = this.inst.component || this.inst.directive;
                    var view = this.inst.view;
                    if (ctrl._ngtt && ctrl._ngtt.ngRoute && ctrl._ngtt.ngRoute.path) {
                        var route = {};
                        route.controller = this.inst.cls;
                        route.controllerAs = ctrl._ngtt.ngRoute.controllerAs || lang_1.getTypeName(this.inst.cls);
                        if (view.template) {
                            route.template = view.template;
                        }
                        else if (view.templateUrl) {
                            route.templateUrl = view.templateUrl;
                        }
                        if (ctrl._ngtt.ngRoute.resolve) {
                            route.resolve = ctrl._ngtt.ngRoute.resolve;
                        }
                        var appName = this.inst.ngAppName;
                        if (!NgRouteAdapter.routeCache.hasOwnProperty(appName)) {
                            NgRouteAdapter.routeCache[appName] = [];
                            var app = this.inst.ngModule;
                            app.config(['$routeProvider', this.routeConfig.bind(this)]);
                        }
                        NgRouteAdapter.routeCache[appName].push({
                            path: ctrl._ngtt.ngRoute.path,
                            route: route
                        });
                    }
                };
                NgRouteAdapter.routeCache = {};
                return NgRouteAdapter;
            })(base_1.BaseAdapter);
            exports_1("NgRouteAdapter", NgRouteAdapter);
        }
    }
});

/* SEE: https://github.com/angular/angular/blob/master/modules/angular2/src/core/annotations_impl/annotations.ts */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};System.register("src/core/annotations_impl/annotations.ts", ['../../facade/lang'], function(exports_1) {
    var lang_1;
    var NgttAnnotation, Directive, Component;
    return {
        setters:[
            function (_lang_1) {
                lang_1 = _lang_1;
            }],
        execute: function() {
            NgttAnnotation = (function () {
                function NgttAnnotation(_ngtt) {
                    this._ngtt = _ngtt;
                }
                return NgttAnnotation;
            })();
            exports_1("NgttAnnotation", NgttAnnotation);
            Directive = (function (_super) {
                __extends(Directive, _super);
                function Directive(_a) {
                    var _b = _a === void 0 ? {} : _a, selector = _b.selector, host = _b.host, _ngtt = _b._ngtt;
                    _super.call(this, _ngtt);
                    this.selector = selector;
                    this.host = host;
                }
                Directive = __decorate([
                    lang_1.CONST()
                ], Directive);
                return Directive;
            })(NgttAnnotation);
            exports_1("Directive", Directive);
            Component = (function (_super) {
                __extends(Component, _super);
                function Component(_a) {
                    var _b = _a === void 0 ? {} : _a, selector = _b.selector, host = _b.host, _ngtt = _b._ngtt;
                    _super.call(this, {
                        selector: selector,
                        host: host,
                        _ngtt: _ngtt
                    });
                }
                Component = __decorate([
                    lang_1.CONST()
                ], Component);
                return Component;
            })(Directive);
            exports_1("Component", Component);
        }
    }
});

/* SEE: https://github.com/angular/angular/blob/master/modules/angular2/src/core/annotations_impl/view.ts */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};System.register("src/core/annotations_impl/view.ts", ['../../facade/lang'], function(exports_1) {
    var lang_1;
    var View;
    return {
        setters:[
            function (_lang_1) {
                lang_1 = _lang_1;
            }],
        execute: function() {
            View = (function () {
                function View(_a) {
                    var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template;
                    this.templateUrl = templateUrl;
                    this.template = template;
                }
                View = __decorate([
                    lang_1.CONST()
                ], View);
                return View;
            })();
            exports_1("View", View);
        }
    }
});

//# sourceMappingURL=app.map